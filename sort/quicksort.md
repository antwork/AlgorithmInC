## 快速排序

### 目的
数组按照从大到小排序

### 算法
步骤一：选取数组第一个(`i=0`)值， 将其存储为k,  这样i位置就空出来了。

步骤二：从数组最后一个(`j`)元素开始向左查找，如果arr[j] > k， 则将arr[i] = arr[j], 将比k大的值存储在`i`的位置， 存完`i`向右移动一位

步骤三：从`i`开始向右查找，如果a[i] < k， 则将arr[j] = arr[i], 将比k小的只存储在`j`的位置， 存完`j`向左移动一位 

步骤四：假设i==j, 表示左右相会了，这时将k的值存储在arr[i], 如此i左边的值均大于等于k, 右边的值均小于等于k。假设没有相会，则继续重复步骤二， 步骤三；

步骤五：以i为分界，将数组分成两部分，继续使用快速排序排列分拆的小数组直到小数组长度等于1才结束。 

#### 理解点
1. 取基准值，将大于基准值的数都放到左边， 小于基准值的都放右边。
2. 采用分治法，将大于基准值和小于基准值的分为两个小数组，对小数组继续排序。
3. 不断循环，直到所有小数组不需要再排序表明整个数组已完成排序。
4. 向右移动时找小于基准值的数，想左移动找大于基准值的数，当左右相会(i==j)时，自然i左边的都是大于基准值的数，i右边都是小于基准值的数。

[quicksort.c源码](quicksort.c)

#### 排序结果

```
int arr[] = {6, 5, 6, 8, 7, 3, 2, 1}

以6为基准排序
6 5 6 8 7 3 2 1 
7 8 6 6 5 3 2 1 
排序左边（8 7 6）
排序右边（5 3 2 1）
排序右边（3 2 1） 

排序结果
8 7 6 6 5 3 2 1 
```